Proposal for Azure IoT Gateway Application structure.
=====================================================

References
----------

[Enterprise Integration Patterns](http://www.enterpriseintegrationpatterns.com/patterns/messaging)

[RabbitMQ](http://www.rabbitmq.com/)

[nanomsg](http://nanomsg.org/)

[Apache Kafka](https://kafka.apache.org/)

Issues encountered during spike:
--------------------------------

When making the DM client spike I ran into problems with combining the device management data flow with the IoT Hub telemtery data flow. 

### Spike Problem 1

My initial attempt at constructung a gateway that would support a device mangement function along with a telemetry function meant I had to take some messages being generated by the Bluetooth module and send them to the device management client.  The initial design looked like this:
1. "Bluetooth" module generated messages, which are recognized by the "Identity" module, the MAC address was converted to deviceName and deviceKey properties, and then republished to be picked up by the "IoTHub" module. Or,
> "Bluetooth" -> "Identity" -> "IoTHub"

2. "Bluetooth" module generated messages, the "DM BLE conversion" module picked messages by MAC address and bluetooth command, then added additional properties and republished them. The "Identity" module would receive them, convert the MAC address to deviceName and deviceKey properties, then republish it, where the  "DM Hub client" would process the message.  Or,
> "Bluetooth" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client" 

The problem was that every message generated by the Bluetooth module would follow the Telemetry path, regardless of whether or not the message was intended for Telemetry consumption. 

### Spike Problem 2

Based on this design, I would have also had to have changed the code for the IoT Hub Module to keep it from sending messages to IoTHub that were intended to be sent to the DM Hub. The same Bluetooth message would generate 2 messages towards the IoT Hub.

For the spike, I avoided the above by removing the IoTHub module from the application.

### [Spike Problem 3]

The application also requires requests to be sent to the Bluetooth device. So, I need both a device to cloud and cloud to device bidirectionality for all modules:
1. Device to cloud (D2C)
> "Bluetooth" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client"
2. Cloud to device (C2D)
> "DM Hub Client" -> "Identity" -> "DM BLE conversion" -> "Bluetooth"

The "Bluetooth" and "Identity" module are already written to be bidirectional. 

I discovered that it was very easy to confuse messages coming into a module.  For example, by the way I initially wrote the "DM BLE conversion" module, messages indended for the D2C path would also be recognized by the "DM BLE conversion" module as a message in the C2D, the output in for the "Identity" module also would be incorrectly recognized as a message in the C2D path.  Each message coming from the "Bluetooth" module would generate up to 2 additional requests back towards the "Bluetooth" module, causing a sort of an infinite loop.

It was very difficult to find a good, generically defined message format which eliminated these looping problems.

Eventually, I solved the problem by modifying all the modules to only process messages from specific sources and targeted to that module only. 

### Spike Problem 4

Device Management callbacks are currently synchronous, where the gateway only processes messages asynchronously.  That meant the callback would have to publish a message to the MessageBus and coordinate with another task for reception of the response message.

### General problem 

Every time we've changed or added features to the gateway application, I've had to modify every module I've used, usually reworking how we receive messages and publish them to the bus. This means our modules are generally not reusable as is.


Objectives for any fix
----------------------

- maximize reusability for modules.

- remove the ambiguity of which modules process any given message, to reduce developer confusion when constructing a gateway.

Proposals for GA release
------------------------

These are the generic proposals for addressing this in the GA release.

1. Continue to have the modules determine which messages it should respond to, and how it publishes new messages to the message bus.
2. Implement some form of message routing.

Before I get into any details about these proposals, I will introduce some concepts and terms to frame the dicsussion.


Routing concepts to consider
----------------------------

These are common routing patterns. A short description of each may be found at the [Enterprise Integration Patterns](http://www.enterpriseintegrationpatterns.com/patterns/messaging) website.

#### Pipes and Filters

This architectural pattern defines a series of processing steps for an incoming message. Each processing module reads from an input pipe, does its work, and posts the message on an outgoing pipe.

The distinction from the gateway is that the modules are expliticly tied together, as each module makes the call directly to the next module. There is no ability for multiple modules to process the same message.

While the gateway isn't a Pipes and Filters architecture, our customers may view the path of messages through the gateway like a pipeline. 
 
### Pub/Sub

This is a very common pattern in message routing, implemented in some variation on all of the messaging systems I reviewed. A producer pusblishes messages on a bus, and a consumer reads it from the bus.  Our current MessageBus implementation could be considered a simple pub/sub pattern. Modules subscribe to the MessageBus on MessageBus_AddModule and publishes to the bus using MessageBus_Publish.

nanomsg has a message bus implementation, its primary distinction is that messages are not sent to the socket that originated the message.

#### Topic based routing

An extension to the pub/sub pattern is to partion the Message Bus by topics. A consumer can subcribe to one or more topics, and a producer can publish a message to specific topics.

RabbitMQ and nanomsg support topic based routing.  nanomsg allows subscribing to messages prepanded with specified text patterns. Apache Kafka and RabbitMQ have topics which route messages to queues which bindings have an exact match to the published message's routing key. (RabbitMQ calls this "direct" routing.)

Some messaging systems allow for wildcards in topics.  RabbitMQ names this "topic" routing. Producers publish messages under topics--words separated by ".". Consumers may subscribe to a named topic or use wildcards to match portions of a topic.

#### Content based routing and filtering

This is where the message bus routes based on content.  This is slightly different than content based filtering, which is what we currently do.

In content based routing, the message bus determines the modules to send to by message content.  In content based filtering, the module receives all messages, and the module determines by evaluating the content if it processines the message.

Most modules have to do some sort of content based filtering, at the very least to ensure it can correctly process the message it receives.

#### Routing slip

A recipe for a sequence of events. Upon receiving a message, the message bus tracks that message as it goes through a series of modules.  It delivers the message to each node in sequence.

Proposal 1
-----------
Revised Content based filtering inside modules
- Work through all the details and not significantly change message bus behavior *except*
- Change MessageBus_Publish to allow a source MODULE_HANDLE (allowed to be NULL.)  The MessageBus then skips the source module when broadcasting to queues. If module handle is NULL, the message is broadcasted to all the nodes. This eliminates some of the hardest to understand looping problems I had.

Advantages:
	- minor code changes, not a lot of extra effort.
	- I've already shown I can get it to work.

Disadvantages:
	- Nothing is really pluggable. Nothing. Does not solve the [General problem](#header)
	- Puts extra effort on our customers to manage the module message handling.
    
Proposal 2
----------

Let's start by proposing some changes. In order to get more pluggable modules, let's add some parameters to the gateway JSON structure
```json
{
    "modules" :
    [ 
        {
            "module name" : "foo",
            "module path" : "F:\\foo.dll",
			"subscribes to" : [ "topic name 1", "topic name 2"],
			"topic" : "topic name 3",
            "args" : ...
        },
        {
            "module name" : "bar",
            "module path" : "F:\\bar.dll",
			"subscribes to" : [ "topic name 2", "topic name 2"],
			"topic" : "topic name 2",
            "args" : ...
        },
        ...
    ]
}
```
The "subscribes to" parameter is a list of named topics for which the module will subscribe.  The "topic" paremeter is the named topic into which the module will publish.  The "module name" and "topic" parameters are independent.

For example, in the BLE gateway sample (arguments elided for space),
```json
{
  "modules": [
    {
      "module name": "IoTHub",
      "module path": "<</path/to/libiothubhttp_hl.so>>",
	  "subscribes to" : [ "identity mapping" ],
	  "topic" : "IoTHubHttp",
      "args": {}
    },
    {
      "module name": "BLE Printer",
      "module path": "<</path/to/libble_printer.so>>",
      "args": null
    },
    {
      "module name": "mapping",
      "module path": "<</path/to/libidentity_map_hl.so>>",
	  "subscribes to" : [ "IoTHubHttp", "SensorTag" ],
	  "topic" : "identity mapping",
      "args": []
    },
    {
      "module name": "SensorTag",
      "module path": "<</path/to/libble_hl.so>>",
	  "subscribes to" : [ "identity mapping" ],
	  "topic" : "SensorTag",
      "args": {}
    },
    {
      "module name": "Logger",
      "module path" : "<</path/to/liblogger_hl.so>>",
      "args": {}
    }
  ]
}
```

The "subscribes to" and "topic" arguments are optional. I'm proposing that a module which does not have a "subscribes to" argument receives all messages, and a module with no "topic" argument will only be received by modules with an empty "subscribes to" argument.  This ensures backwards compatibility.

These argument funtionalities are handled entirely by the MessageBus.  The modules themselves do not know which topics they are subscribed to, only that if a message is received, it was filtered by the MessageBus.  Also, it would post a message to the MessageBus, not knowing which topic it might be posted under.

For example, we could define a second identity mapping module which also listens to the SenorTag, but posts to a different topic, or allowing us to route to a DM client or even a different identity on the IoTHub. This would help address [Spike Problem 2](#header).

Advantages: 
- Modules do not need to be modified or recompiled when topics and application structure changes.
- We do not need to define addressing of modules or topics in the module code.
- May reduce the total message processing done by each module. (Need to do the proof on this.) 
- Helps reduce customer confusion in developing gateway applications.

Disadvantages:
- Effort to do this work.
- Increases MessageBus complexity.
- Modules may only post to one topic.
- Modules have no ability to make decisions and post to alternate topics.
- Does not solve [Spike Problem 3](#header) or [Spike Problem 4](#header), so we still need to perform content-based filtering inside the modules. However, in the DM spike, I had to filter messages broadcasting from 4 modules, so reducing the number and types of messages each module receives, it might reduce the complexity of the content based filter.


	
Gateway application features
----------------------------
I think the gateway as we are targeting its use has these qualities:

- Stable and discreet number of modules.

>It doesn’t mean it’s not configurable or dynamic, only that there typically won’t be an arbitrarily large number of modules, nor frequent adding and removing modules.  Modules change when gateway features change.

- Ability to process heterogeneous messages. 

>The gateway can be agnostic about the types of messages that pass through.  I know from our own use and potential customer usage that even telemetry messages will be different message types, and different processing is expected to happen with these types.

- Zero copy/minimal copy.  

> We’ve been copying and modifying properties, but not the buffers, and we should keep copying messages to a minimum.

- Pluggable, reusable modules

> We want common functionality (send to IoTHub, identity mapping) to be useful to a general audience, and usable by any application that needs that functionality, without rewriting code, or minimal rewriting.

- Broadcasting messages to multiple consumers.

> A module doesn’t always need to know the intended consumer, and sometimes a module (like a logger) wants to see everything.  We have applications where the same messages should be processed by multiple modules. For example, raw telemetry should be saved to the hub, but it should also be analyzed for thresholds and alarm conditions on the gateway.  

The gateway we have implements all the desired features except for one, pluggable modules.  I ahve had to make (usually minor) changes and recompile to make modules that work for a new application.