Proposal for Azure IoT Gateway Application structure.
=====================================================

Issues encountered during spike:
--------------------------------

When making the DM client spike I ran into problems with combining the device management data flow with the IoT Hub telemtery data flow. 

### Spike Problem 1: 

My initial attempt at constructung a gateway that would support a device mangement function along with a telemetry function meant I had to take some messages being generated by the Bluetooth module and send them to the device management client.  The initial design looked like this:
1. "Bluetooth" module generated messages, which are recognized by the "Identity" module, the MAC address was converted to deviceName and deviceKey properties, and then republished to be picked up by the "IoTHub" module. Or,
> "Bluetooth" -> "Identity" -> "IoTHub"

2. "Bluetooth" module generated messages, the "DM BLE conversion" module picked messages by MAC address and bluetooth command, then added additional properties and republished them. The "Identity" module would receive them, convert the MAC address to deviceName and deviceKey properties, then republish it, where the  "DM Hub client" would process the message.  Or,
> "Bluetooth" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client" 

The problem was that every message generated by the Bluetooth module would follow the Telemetry path, regardless of whether or not the message was intended for Telemetry consumption. 

### Spike Problem 2:

Based on this design, I would have also had to have changed the code for the IoT Hub Module to keep it from sending messages to IoTHub that were intended to be sent to the DM Hub. The same Bluetooth message would generate 2 messages towards the IoT Hub.

For the spike, I avoided the above by removing the IoTHub module from the application.

### Spike Problem 3:

The application also requires requests to be sent to the Bluetooth device. So, I need both a device to cloud and cloud to device bidirectionality for all modules:
1. Device to cloud (D2C)
> "Bluetooth" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client"
2. Cloud to device (C2D)
> "DM Hub Client" -> "Identity" -> "DM BLE conversion" -> "Bluetooth"

The "Bluetooth" and "Identity" module are already written to be bidirectional. 

I discovered that it was very easy to confuse messages coming into a module.  For example, by the way I initially wrote the "DM BLE conversion" module, messages indended for the D2C path would also be recognized by the "DM BLE conversion" module as a message in the C2D, the output in for the "Identity" module also would be incorrectly recognized as a message in the C2D path.  Each message coming from the "Bluetooth" module would generate up to 2 additional requests back towards the "Bluetooth" module, causing a sort of an infinite loop.

It was very difficult to find a good, generically defined message format which eliminated these looping problems.

Eventually, I solved the problem by modifying all the modules to only process messages from specific sources and targeted to that module only. 

### Spike Problem 4:

Device Management callbacks are currently synchronous, where the gateway only processes messages asynchronously.  That meant the callback would have to publish a message to the MessageBus and coordinate with another task for reception of the response message.

### General problem 

Every time we've changed or added features to the gateway application, I've had to modify every module I've used, usually reworking how we receive messages and publish them to the bus. This means our modules are generally not reusable as is.


Objectives for any fix
----------------------

- maximize reusability for modules.

- remove the ambiguity of which modules process any given message, to reduce developer confusion.

Proposals for GA release
------------------------

These are the generic proposals for addressing this in the GA release.

1. Continue to have the modules determine which messages it should respond to, and how it publishes new messages to the message bus.
2. Implement some form of message routing.

Gateway application features
----------------------------
I think the gateway as we are targeting its use has these qualities:

- Stable and discreet number of modules.

>It doesn’t mean it’s not configurable or dynamic, only that there typically won’t be an arbitrarily large number of modules, nor frequent adding and removing modules.  Modules change when features change.

- Ability to process heterogeneous messages. 

>The gateway can be agnostic about the types of messages that pass through.  I know from our own use and potential customer usage that even telemetry messages will be different message types, and different processing is expected to happen with these types.

- Zero copy/minimal copy.  

> We’ve been copying and modifying properties, but not the buffers, and we should keep copying messages to a minimum.

- Pluggable, reusable modules

> We want common functionality (send to IoTHub, identity mapping) to be useful to a general audience, and usable by any application that needs that functionality, without rewriting code, or minimal rewriting.

- Broadcasting messages to multiple consumers.

> A module doesn’t always need to know the intended consumer, and sometimes a module (like a logger) wants to see everything.

Proposal 1:
-----------
Revised Content based filtering inside modules
- Work through all the details and not significantly change message bus behavior *except*
- Change MessageBus_Publish to allow a source MODULE_HANDLE (allowed to be NULL.)  The MessageBus then skips the source module when broadcasting to queues. If module handle is NULL, the message is broadcasted to all the nodes. This eliminates some of the hardest to understand looping problems I had.

Advantages:
	- minor code changes, not a lot of extra effort.
	- I've already shown I can get it to work.

Disadvantages:
	- Nothing is really pluggable. Nothing.
	- Puts extra effort on our customers to manage the module message handling.
    
