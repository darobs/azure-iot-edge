Proposal for Azure IoT Gateway Application structure.
=====================================================

References
----------

[Enterprise Integration Patterns](http://www.enterpriseintegrationpatterns.com/patterns/messaging)

[RabbitMQ](http://www.rabbitmq.com/)

[nanomsg](http://nanomsg.org/)

[Apache Kafka](https://kafka.apache.org/)

Issues encountered during spike:
--------------------------------

When making the DM client spike I ran into problems with combining the device 
management data flow with the IoT Hub telemtery data flow. 

### Spike Problem 1

My initial attempt at constructung a gateway that would support a device 
mangement function along with a telemetry function meant I had to take some 
messages being generated by the BLE module and send them to the device 
management client.  The initial design looked like this:
1. "BLE" module generated messages, which are recognized by the "Identity" 
module, the MAC address was converted to deviceName and deviceKey properties, and then republished to be picked up by the "IoTHub" module. Or,
> "BLE" -> "Identity" -> "IoTHub"

2. "BLE" module generated messages, the "DM BLE conversion" module picked 
messages by MAC address and BLE command, then added additional properties and 
republished them. The "Identity" module would receive them, convert the MAC 
address to deviceName and deviceKey properties, then republish it, where the 
"DM Hub client" would process the message.  Or,
> "BLE" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client" 

The problem was that every message generated by the BLE module would follow the 
Telemetry path, regardless of whether or not the message was intended for 
Telemetry consumption. 

### Spike Problem 2

Based on this design, I would have also had to have changed the code for the IoT 
Hub Module to keep it from sending messages to IoTHub that were intended to be 
sent to the DM Hub. The same BLE message would generate 2 messages towards the 
IoT Hub.

For the spike, I avoided the above by removing the IoTHub module from the 
application.

### Spike Problem 3

The application also requires requests to be sent to the BLE device. So, I need 
both a device to cloud and cloud to device bidirectionality for all modules:
1. Device to cloud (D2C)
> "BLE" -> "DM BLE conversion" -> "Identity" -> "DM Hub Client"
2. Cloud to device (C2D)
> "DM Hub Client" -> "Identity" -> "DM BLE conversion" -> "BLE"

The "BLE" and "Identity" module are already written to be bidirectional. 

I discovered that it was very easy to confuse messages coming into a module. For 
example, by the way I initially wrote the "DM BLE conversion" module, messages 
indended for the D2C path would also be recognized by the "DM BLE conversion" 
module as a message in the C2D, the output in for the "Identity" module also 
would be incorrectly recognized as a message in the C2D path.  Each message 
coming from the "BLE" module would generate up to 2 additional requests back 
towards the "BLE" module, causing a sort of an infinite loop.

It was very difficult to find a good, generically defined message format which 
eliminated these looping problems.

Eventually, I solved the problem by modifying all the modules to only process 
messages from specific sources and targeted to that module only. 

### Spike Problem 4

Device Management callbacks are currently synchronous, where the gateway only 
processes messages asynchronously.  That meant the callback would have to 
publish a message to the MessageBus and coordinate with another task for 
reception of the response message.

### General problem 

Every time we've changed or added features to the gateway application, I've had 
to modify every module I've used, usually reworking how we receive messages and 
publish them to the bus. This means our modules are generally not reusable as is.


Objectives for any fix
----------------------

- allow us to produce a working DM client sample.

- maximize reusability for modules.

- remove the ambiguity of which modules process any given message, to reduce 
developer confusion when constructing a gateway.

Proposals for GA release
------------------------

These are the generic proposals for addressing this in the GA release.

1. Continue to have the modules determine which messages it should respond to, 
and how it publishes new messages to the message bus.
2. Implement some form of message routing.

Before I get into any details about these proposals, I will introduce some 
concepts and terms to frame the dicsussion.


Routing concepts to consider
----------------------------

These are common routing patterns. A short description of each may be found at 
the [Enterprise Integration Patterns](http://www.enterpriseintegrationpatterns.com/patterns/messaging) 
website.

#### Pipes and Filters

This architectural pattern defines a series of processing steps for an incoming 
message. Each processing module reads from an input pipe, does its work, and 
posts the message on an outgoing pipe.

The distinction from the gateway is that the modules are expliticly tied 
together, as each module makes the call directly to the next module. There is no 
ability for multiple modules to process the same message.

While the gateway isn't a Pipes and Filters architecture, our customers may view 
the path of messages through the gateway like a pipeline. 
 
### Pub/Sub

This is a very common pattern in message routing, implemented in some variation 
on all of the messaging systems I reviewed. A producer pusblishes messages on a 
bus, and a consumer reads it from the bus.  Our current MessageBus implementation 
could be considered a simple pub/sub pattern. Modules subscribe to the MessageBus 
on MessageBus_AddModule and publishes to the bus using MessageBus_Publish.

nanomsg has a message bus implementation, its primary distinction is that 
messages are not sent to the socket that originated the message.

#### Topic based routing

An extension to the pub/sub pattern is to partion the Message Bus by topics. A 
consumer can subcribe to one or more topics, and a producer can publish a 
message to specific topics.

Apache Kafka, RabbitMQ and nanomsg support topic based routing.  nanomsg allows 
subscribing to messages prepanded with specified text patterns. Kafka and 
RabbitMQ have topics which route messages to queues which bindings have an exact 
match to the published message's routing key. (RabbitMQ calls this "direct" 
routing.)

Some messaging systems allow for wildcards in topics.  RabbitMQ names this 
"topic" routing. Producers publish messages under topics--words separated by ".". 
Consumers may subscribe to a named topic or use wildcards to match portions of a 
topic.

#### Content based routing and filtering

This is where the message bus routes based on content.  This is slightly 
different than content based filtering, which is what we currently do.

In content based routing, the message bus determines the modules to send to by 
message content.  In content based filtering, the module receives all messages, 
and the module determines by evaluating the content if it processines the message.

Most modules have to do some sort of content based filtering, at the very least 
to ensure it can correctly process the message it receives.

#### Routing slip

A recipe for a sequence of events. Upon receiving a message, the message bus 
tracks that message as it goes through a series of modules.  It delivers the 
message to each node in sequence.

Proposal 1
-----------
Revised Content based filtering inside modules
- Work through all the details and not significantly change message bus behavior 
*except*
- Change MessageBus_Publish to allow a source MODULE_HANDLE (allowed to be 
NULL.)  The MessageBus then skips the source module when broadcasting to queues. 
If module handle is NULL, the message is broadcasted to all the nodes. This 
eliminates some of the hardest to understand looping problems I had.

### Changes to MessageBus

Modified function:
```C
extern MESSAGE_BUS_RESULT MessageBus_Publish(MESSAGE_BUS_HANDLE bus, MESSAGE_HANDLE message, MODULE_HANDLE source);
```

Advantages:
	- minor code changes, not a lot of extra effort.
	- I've already shown I can get it to work.

Disadvantages:
	- Nothing is really pluggable. Nothing. Does not solve the [General problem](#header).
	- Puts extra effort on our customers to manage the module message handling.
    
Proposal 2
----------

In order to get more pluggable modules, we will add some parameters to the 
gateway JSON structure.
```json
{
    "modules" :
    [ 
        {
            "module name" : "foo",
            "module path" : "F:\\foo.dll",
			"subscribes to" : [ "topic name 1", "topic name 2"],
			"topic" : "topic name 3",
            "args" : ...
        },
        {
            "module name" : "bar",
            "module path" : "F:\\bar.dll",
			"subscribes to" : [ "topic name 2", "topic name 2"],
			"topic" : "topic name 2",
            "args" : ...
        },
        ...
    ]
}
```
The "subscribes to" parameter is a list of named topics for which the module 
will subscribe.  The "topic" paremeter is the named topic into which the module 
will publish.  The "module name" and "topic" parameters are independent.

For example, in the BLE gateway sample (arguments elided for space),
```json
{
  "modules": [
    {
      "module name": "IoTHub",
      "module path": "<</path/to/libiothubhttp_hl.so>>",
	  "subscribes to" : [ "identity mapping" ],
	  "topic" : "IoTHubHttp",
      "args": {}
    },
    {
      "module name": "BLE Printer",
      "module path": "<</path/to/libble_printer.so>>",
      "args": null
    },
    {
      "module name": "mapping",
      "module path": "<</path/to/libidentity_map_hl.so>>",
	  "subscribes to" : [ "IoTHubHttp", "SensorTag" ],
	  "topic" : "identity mapping",
      "args": []
    },
    {
      "module name": "SensorTag",
      "module path": "<</path/to/libble_hl.so>>",
	  "subscribes to" : [ "identity mapping" ],
	  "topic" : "SensorTag",
      "args": {}
    },
    {
      "module name": "Logger",
      "module path" : "<</path/to/liblogger_hl.so>>",
      "args": {}
    }
  ]
}
```

The "subscribes to" and "topic" arguments are optional. I'm proposing that a 
module which does not have a "subscribes to" argument receives all messages, 
and a module with no "topic" argument will only be received by modules with an 
empty "subscribes to" argument.  This ensures backwards compatibility with 
existing JSON configuration.

These argument funtionalities are handled entirely by the MessageBus.  The 
modules themselves do not know which topics they are subscribed to, only that if 
a message is received, it was filtered by the MessageBus.  Also, it would post a 
message to the MessageBus, not knowing which topic it might be posted under.

For example, we could define a second identity mapping module which also listens 
to the SenorTag, but posts to a different topic, or allowing us to route to a DM 
client or even a different identity on the IoTHub. This would help address 
[Spike Problem 2](#header).

### Changes to MessageBus

Modified functions:
```C
extern MESSAGE_BUS_RESULT MessageBus_AddModule(MESSAGE_BUS_HANDLE bus, MODULE_HANDLE module, const MODULE_APIS* module_apis, STRING_HANDLE topic);

extern MESSAGE_BUS_RESULT MessageBus_Publish(MESSAGE_BUS_HANDLE bus, MESSAGE_HANDLE message, MODULE_HANDLE source);
```

New functions:
```C
extern MESSAGE_BUS_RESULT MessageBus_SubscribeModule(MESSAGE_BUS_HANDLE bus, MODULE_HANDLE module, STRING_HANDLE topic);
extern MESSAGE_BUS_RESULT MessageBus_UnsubscribeModule(MESSAGE_BUS_HANDLE bus, MODULE_HANDLE module, STRING_HANDLE topic);
```


Advantages: 
- Modules do not need to be modified or recompiled when topics and application
 structure changes.
- We do not need to define addressing of modules or topics in the module code.
- May reduce the total message processing done by each module. *(Need to do the 
proof on this.)*
- Helps reduce customer confusion in developing gateway applications.
- Functionally compatible with existing messaging services.

Disadvantages:
- Effort to do this work.
- Increases MessageBus complexity.
- Modules may only post to one topic.
- Modules have no ability to make decisions and post to alternate topics.
- Does not solve [Spike Problem 3](#header) or [Spike Problem 4](#header), so we 
still need to perform content-based filtering inside the modules. However, in 
the DM spike, I had to filter messages broadcasting from 4 modules, so reducing 
the number and types of messages each module receives, it might reduce the 
complexity of the content based filter.

Conclusion
-----------

There is no need to implement [Proposol 2](#header) to implement a first class 
DM client experience. While any improvements made to the MessageBus 
implementation would make the design of a gateway easier, I have been able to 
resolve the issues I had during the spike using the simple content based filter 
for each module. More careful design of a DM Hub application will keep existing 
modules reasonably reusable.

However, improvements to the MessageBus are in our current task list, and I am 
proposing we implement Proposal 2 as part of those improvements.
